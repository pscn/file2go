// Code generated by "file2go -devel -output template/files.go template/files.tmpl"; DO NOT EDIT.

// Encoded files:
// â†’ template/files.tmpl

package template

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"time"
)

// file stores the content and modTime of the decoded string
type file struct {
	content *[]byte
	modTime *time.Time
}

var container map[string]*file

// Init populates *file with data decoded from base64Encoded string
func decode(base64Encoded string) (*file, error) {
  gzipEncoded, err := base64.StdEncoding.DecodeString(base64Encoded)
	if err != nil {
		return nil, fmt.Errorf("failed to decode data(BASE64): %s", err)
	}

	var buf bytes.Buffer
	_, err = buf.Write(gzipEncoded)
	if err != nil {
		return nil, fmt.Errorf("failed buffer decode data: %s", err)
	}

	zr, err := gzip.NewReader(&buf)
	if err != nil {
		return nil, fmt.Errorf("failed to create reader from buffer: %s", err)
	}
	defer zr.Close()

  decoded, err := ioutil.ReadAll(zr)
	if err != nil {
		return nil, fmt.Errorf("failed to decode data(GZIP): %s", err)
	}

	return &file{
		content: &decoded,
		modTime: &zr.ModTime,
	}, nil
}

func init() {
  container = make(map[string]*file)
  var err error
  
  container["template/files.tmpl"], err = decode(`` +
    `H4sICFK1sFwA/1ptbHNaWE11ZEcxd2JBPT0ArFRRa+Q2EH62fsXUcMEOiw0lXGGPfc` +
    `htlpKHyx1NoNCwFK09csTakpHlHlmj1/6A/sT+kjKy7Nvb7D005CVZa6Rvvvnmm8lz` +
    `WOsSoUKFhlssYfcMsZA1/lxpGIbs2lR9g8p2zsUf4OYz3H1+gM3N7UPGWJ7DRhW6xB` +
    `LoRbdkw2C4qhCytVaWS4XGuTyHf//+h7DueIPOsWFAVTrHWl7seYUU+bKvnGNMNq02` +
    `FhIWxbtni13MorjQTWuw6/LqIFs6QEopVZXveIfvr+hINJb+SZ1L3VtZ04eVDcYs9S` +
    `yJHXRWG+zAPiEUWllUFrgqodHlg2wQtPChEseCOmukqph9bnF6bvrCwsCi6fXl45ZY` +
    `smiCuKScGf1kjrG/uPGJvAzQ8PZxxNxeEp7ndaukhVa3fc0tduAD8FXaJyi55TMXYX` +
    `QDY7WT3oGe6FURriXnLqSQeNAFoDHapDAwABIyXPPnsFwF9Ozelpsgb3bjYe89zvfg` +
    `KYuk8C9/WoGSNYkSGbS9UfS5ANHYbEMJRRILLmsswerA05eWfLy+37y/Spfwros9iZ` +
    `RFjrGIRNv1Anz7s4+9EGhY9OfIc0Wh7HcjLSZHRbyGzs4jH1N6QeVgZnUoWXaHX39D` +
    `XqJJLna9eKUGhUFuEYwHCo31VE7SRyUSv4PJ1rXuMEkZg8kPM63R7Bmxuq7r5GDeoD` +
    `G//nH75WVbAsYFeYkwwwgs4WLixKJpDJZwcTDZp/FjwSK3oNw0Ed6tUkmbjEb8Nh0r` +
    `aPgek9MhSRkAOYIq8gZmAMMAL3fMMdhjPK+aeDsZJ8zItJ+S9VOv9iMEjfIvV6lzw5` +
    `DRH7+cKPOplABRy5UsEq8LgBsGQFWCc3NxAS8h8oo3eDSG47L4bhClgHE49Z7a+a2C` +
    `6fn2A4XoKkBoAYWyIP8oLACV/8Muh1X+rgOlLQjdqzJewJQhPaX+qe/O0A/sj7bfbM` +
    `LTks968Eg3MncgG6BmCsEz59SbN+vbCBis+qYCBvY/EHAugPSY0wcNTwv/HxoGKGKR` +
    `54Ba/BcAAP//O8qa8NIHAAA=`)
  if err != nil {
  	panic(err)
  }
}

func Content(filename string) (*[]byte, error) {
  if file, ok := container[filename]; ok {
    return file.content, nil
  }
  return nil, fmt.Errorf("file2go %s not found", filename)
}

func ContentMust(filename string) *[]byte {
	content, err := Content(filename)
	if err != nil {
		panic(err)
	}
	return content
}

func ModTime(filename string) (*time.Time, error) {
  if file, ok := container[filename]; ok {
    return file.modTime, nil
  }
  return nil, fmt.Errorf("file2go %s not found", filename)
}

func ModTimeMust(filename string) *time.Time {
	modTime, err := ModTime(filename)
	if err != nil {
		panic(err)
	}
	return modTime
}

// eof