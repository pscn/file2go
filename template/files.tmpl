// Code generated by "file2go {{.Arguments}}"; DO NOT EDIT.

// Encoded files:
{{range .Container}}// â†’ {{.Name}}
{{end}}
package {{.Pkg}}

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"log"
)

var container map[string]*[]byte

// decode the base64Encoded string and return a *[]byte for the decoded data
func decode(base64Encoded string) *[]byte {
	gzipEncoded, err := base64.StdEncoding.DecodeString(base64Encoded)
	if err != nil {
		log.Panicf("failed to decode data(BASE64): %s", err)
	}

	var buf bytes.Buffer
	_, err = buf.Write(gzipEncoded)
	if err != nil {
		log.Panicf("failed buffer decode data: %s", err)
	}

	zr, err := gzip.NewReader(&buf)
	if err != nil {
		log.Panicf("failed to create reader from buffer: %s", err)
	}
	defer zr.Close()

	decoded, err := ioutil.ReadAll(zr)
	if err != nil {
		log.Panicf("failed to decode data(GZIP): %s", err)
	}

	return &decoded
}

func init() {
	container = make(map[string]*[]byte)
	{{ range .Container}}
	container["{{.Name}}"] = decode({{range (Chunk .Content 74)}}{{.}}{{end}}){{ end }}
}

// Content for the given filename
func Content(filename string) (*[]byte, error) {
	if content, ok := container[filename]; ok {
		return content, nil
	}
	return nil, fmt.Errorf("file2go %s not found", filename)
}

// ContentMust for the given filename, panics if filename not found
func ContentMust(filename string) *[]byte {
	content, err := Content(filename)
	if err != nil {
		log.Panic(err)
	}
	return content
}

// eof
