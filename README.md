## Experimental library to convert arbitrary files to gocode

DO NOT USE!

If you still want to use it, you could try:

````shell
go get github.com/pscn/file2go
````

And add something like this to your go file:

````shell
//go:generate file2go -v -t -o template/files.go template/*.tmpl
````

Finally call:

````shell
go generate
````

This will generate a file ````template/files.go```` and ````template/files_test.go```` that contains all ````*.tmpl```` in the ````template```` directory.  To get the content use ````template.Content("template/files.tmpl")```` or ````template.Content("template/files_test.tmpl")````.

The generated file contains all the code required to decode the gzip'd & base64 encoded string.

This is how the generated files looks like.

````template/files.go````:

````go
// Code generated by "file2go -v -d -t -o template/files.go template/*.tmpl"; DO NOT EDIT.

// Encoded files:
// → template\files.tmpl
// → template\files_test.tmpl

package template

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
)

var container map[string]*[]byte

// decode the base64Encoded string and return a *[]byte for the decoded data
func decode(base64Encoded string) (*[]byte, error) {
	gzipEncoded, err := base64.StdEncoding.DecodeString(base64Encoded)
	if err != nil {
		return nil, fmt.Errorf("failed to decode data(BASE64): %s", err)
	}

	var buf bytes.Buffer
	_, err = buf.Write(gzipEncoded)
	if err != nil {
		return nil, fmt.Errorf("failed buffer decode data: %s", err)
	}

	zr, err := gzip.NewReader(&buf)
	if err != nil {
		return nil, fmt.Errorf("failed to create reader from buffer: %s", err)
	}
	defer zr.Close()

	decoded, err := ioutil.ReadAll(zr)
	if err != nil {
		return nil, fmt.Errorf("failed to decode data(GZIP): %s", err)
	}

	return &decoded, nil
}

func init() {
	container = make(map[string]*[]byte)
	var err error
	
	container["template\files.tmpl"], err = decode(`` +
    `H4sICAAAAAAA/2RHVnRjR3hoZEdWY1ptbHNaWE11ZEcxd2JBPT0ArFTRatw6EH22vm` +
    `KuIUG+LDZcQi4k7EOyWUoemoQmUGhYinY1csTa0iLLKVmj135AP7FfUiTLm91s0kLo` +
    `iw0jzdE5M2emKGCiOUKJCg2zyGH+BKmQFf5Xaui6/MyUbY3KNs6lp3BxDVfXdzC9uL` +
    `zLCSkKmKqF5sjBZzQnpOsMUyVCPtHKMqnQOFcU8PP7D491xWp0jnQdKu4cWbHFkpXo` +
    `T26WpXOEyHqljQVKknT+ZLFJSZIudL0y2DRFuZYrH0D/pFRlMWcNHh/5kKit/0ldSN` +
    `1aWaUkI+SRGVgMNKBmq/vGGqnK2b/3M48e+HP0/ME+IPRwg6D+LjDFwaBtjQIGMRGE` +
    `NiGjT+bAmWVEtGoRI/Q1qAxozB8BGqNNBh1JvKh4L4ThZByJ5LeWT6PU/CLg3gagXf` +
    `SMJFKEzH/GoGTlQZPIWMlqBKK2+dS/J2gqmKyQg9WDbs+cnp/dTo+PshM4aNJAIiOJ` +
    `IyTxBZy3AkIr8vNWCDQk+drzHPuj/LORFumWiPfQmQfkbUp7VNZmUx3/WH6F3z4h42` +
    `jo4bwV76zBwiCzCCYAgTC6jlRePJ9w9PzWJp9UukGaER/a7Vnvu9yTOqsqujZ/oS8f` +
    `vlze7HclYhxuGChZEUd6/0klLQ3Genb+GGq2RLo/AFnfYs8xGJIkXQf787uFdZ9upj` +
    `idDT6Inh9Gn04eWrXsEVBZ+P8oc67rcv8Jc/9qZVZMyQWNKrsOUHFwzusKG6qHGuau` +
    `lI+owspRrMZeebxDh+hvp06KsBlQ2RHope/fs8QBYHbqj7a6tsnwBfe2eLObcXseNK` +
    `C0Z90qno42fLNdVR/b5i1lIwhlaUCKTewZcke3R9nXPiys6IfAPhr2Zb3+3BXyohBR` +
    `BmpBfgUAAP//AGBoyEYGAAA=`)
	if err != nil {
		panic(err)
	}
	container["template\files_test.tmpl"], err = decode(`` +
    `H4sICAAAAAAA/2RHVnRjR3hoZEdWY1ptbHNaWE5mZEdWemRDNTBiWEJzAKRSTWsbMR` +
    `A9r0D/4UVQui5lF3rc4EOJU+ihTg8+BoK6mt2IrCUjaU3Lomt/QH9if0mRYmKntvtB` +
    `bmL05s17b6aucWUVoSdDTgZS+PINotMDvestpql67/pxTSb4GMUlFjdY3qxwvfi4qj` +
    `jjrK6xIh+06dFZB23aYVSkkAh8w9k0OWl6QnVlTZDakIuxrvHz+4/EvZRrijGhyKj0` +
    `2Mj2QfaU/j4/9KnCmV5vrAsoOStEeJwlOJulr240bZ6f2MmEhSW/tOH6q/ahDHizg1` +
    `erGSbOiru3IOfQzLHDl0LMOCt0l+vzOYweMrII1QcZ5NCVYgdt4CiMzpCCsQluXe6N` +
    `nMVTUrIGfywC2EqXx2WOU/nslR4IfUrrUPHFnxTjdt90K2BsQGdHoxq88iLzZ/1P2Z` +
    `+08Wn0f0tVUUcOqbF8LCR1OWVHrd2SK2eXeJ7usdg0p4G/t+OgcC+3hI00un2tst2U` +
    `chHL9Lzbh5J6dhv8P76zTl9o8eLfLaZtnLV57ih+t35wE8+3WNcg23H2KwAA//8qp6` +
    `S53QMAAA==`)
	if err != nil {
		panic(err)
	}
}

// Content for the given filename
func Content(filename string) (*[]byte, error) {
	if content, ok := container[filename]; ok {
		return content, nil
	}
	return nil, fmt.Errorf("file2go %s not found", filename)
}

// ContentMust for the given filename, panics if filename not found
func ContentMust(filename string) *[]byte {
	content, err := Content(filename)
	if err != nil {
		panic(err)
	}
	return content
}

// eof

````

````template/files_test.go````:

````go
// Code generated by "file2go -v -d -t -o template/files.go template/*.tmpl"; DO NOT EDIT.

// Testing for included files:
// → template\files.tmpl
// → template\files_test.tmpl

package template

import (
	"testing"
)

func TestContentDoesNotExist(t *testing.T) {
	_, err := Content("")
	if err == nil {
		t.Fatalf("Content: returned no error")
	}
}

func TestContentExists(t *testing.T) {
  var err error
	_, err = Content("template\files.tmpl")
	if err != nil {
		t.Fatalf("Content \"template\files.tmpl\" not found: %s", err)
	}
	_, err = Content("template\files_test.tmpl")
	if err != nil {
		t.Fatalf("Content \"template\files_test.tmpl\" not found: %s", err)
	}
}

func TestContentMustDoesNotExist(t *testing.T) {
	defer func() {
		if r := recover(); r == nil {
			t.Fatalf("ContentMust: should have panic'd")
		}
	}()
	_ = ContentMust("")
	t.Fatalf("ContentMust: should have panic'd")
}

func TestContentMustExist(t *testing.T) {
	defer func() {
		if r := recover(); r != nil {
			t.Fatalf("ContentMust: should not have panic'd")
		}
	}()
	_ = ContentMust("template\files.tmpl")
	_ = ContentMust("template\files_test.tmpl")
}

// eof

````

Content is GZIPed and BASE64 encoded.

This is likely to change without further notice so => DO NOT USE ;)

### Better Alternatives

[https://github.com/a-urth/go-bindata](https://github.com/a-urth/go-bindata) might provide a more production ready approach?