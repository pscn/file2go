## Experimental library to convert arbitrary files to gocode

DO NOT USE!

If you still want to use it, you could try:

````shell
go get github.com/pscn/file2go
````

And add something like this to your go file:

````shell
//go:generate file2go -verbose -output templates/files.go templates/index.html templates/style.css
````

Finally call:

````shell
go generate
````

This will generate a file ````templates/files.go```` that contains ````templates/index.html```` and ````templates/style.css````.  To get the content use ````templates.Content("templates/index.html")```` or ````templates.Content("templates/style.css")````.

The generated file contains all the code required to decode the gzip'd & base64 encoded string.  No external dependencies :)

This is how the generated file looks like (contains the template to render the code):

````go
// Code generated by "file2go -devel -output template/files.go template/files.tmpl"; DO NOT EDIT.

// Encoded files:
// â†’ template/files.tmpl

package template

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"time"
)

// file stores the content and modTime of the decoded string
type file struct {
	content *[]byte
	modTime *time.Time
}

var container map[string]*file

// Init populates *file with data decoded from base64Encoded string
func decode(base64Encoded string) (*file, error) {
	gzipEncoded, err := base64.StdEncoding.DecodeString(base64Encoded)
	if err != nil {
		return nil, fmt.Errorf("failed to decode data(BASE64): %s", err)
	}

	var buf bytes.Buffer
	_, err = buf.Write(gzipEncoded)
	if err != nil {
		return nil, fmt.Errorf("failed buffer decode data: %s", err)
	}

	zr, err := gzip.NewReader(&buf)
	if err != nil {
		return nil, fmt.Errorf("failed to create reader from buffer: %s", err)
	}
	defer zr.Close()

	decoded, err := ioutil.ReadAll(zr)
	if err != nil {
		return nil, fmt.Errorf("failed to decode data(GZIP): %s", err)
	}

	return &file{
		content: &decoded,
		modTime: &zr.ModTime,
	}, nil
}

func init() {
	container = make(map[string]*file)
	var err error

	container["template/files.tmpl"], err = decode(`` +
		`H4sICCmRsFwA/1ptbHNaWE11ZEcxd2JBPT0ArFTdauNGFL7WPMWpYIMUjAQlbMGLL7` +
		`KOKbnY7NIECg2mjKUzymBpRoxGXWIxt32APmKfpJzRSOt1vBcNubE1f9/5zne+c/Ic` +
		`1rpEqFCh4RZL2D1DLGSNP1cahiG7NlXfoLKdc/EHuPkMd58fYHNz+5AxluewUYUusQ` +
		`R60S3ZMBiuKoRsrZXlUqFxLs/h37//Iaw73qBzbBhQlc6xlhd7XiGdfNlXzjEmm1Yb` +
		`CwmL4t2zxS5mUVzopjXYdXl1kC1tIIWUqsp3vMP3V7QlGkt/UudS91bWtLCywZilni` +
		`Wxg85qgx0o3uACCq0sKgtcldDo8kE2CFqAfUIocUyps0aqitnnFicA0xcWBhZNry8f` +
		`t8STRRPEJUXN6JM5xv7ixgfyQkDD28cRc3tJeJ7ZrZIWWt32NbfYgT+Ar9I+Qcktn7` +
		`kIoxsY850UD/REr4pwLTl3IYXEgy4AjdEmhYEBkJThmt+H5SqgZ/e23ASBsxsPe+9x` +
		`vgdPWSSFf/nTCpSsSZTIoO2NouUCRGOzDQUUSSy4rLEEqwNPn1ry8fp+8/4qXcK7Lv` +
		`YkUhY5xiISbdcL8AbIPvZCoGHRnyPPFR1lvxtpMTlK4jV0dh75mNILKgczq0PBsjv8` +
		`+hvyEk1ysevFKzUoDHKLYDxQKKynchI+KpH4HUy2rnWHScoYTH6YaY12z4jVdV0nB/` +
		`MGhfn1j9svL8sSMC7IS4QZWmAJFxMnFk1tsISLg8k+jYsFi9yCYlNHeLdKJW0yGvFb` +
		`d6yg4XtMTpskZQDkCMrIG5gBDAO8nDLHYI/xPGzi7WSc0CPThErWT73ajxDUyr9cpc` +
		`4NQ0Y/fjxR5FMpAaKWK1kkXhcANwyAqgTn5uQCXkLkadQcteE4LL5rRClgbE69p3J+` +
		`y2B6vv1AR3QVIJSAjrIg/ygsAKX/wyqHYf6uA6UtCN2rMl7AFCE9pf6p787QD+yPpt` +
		`9swtOUz3rwSDcydyAboGYKwTPn1Jsn69sIGKz6pgIG9j8QcE6A9JjDBw1PE/8fGgYo` +
		`YpHngFr8FwAA///9W6tM1AcAAA==`)
	if err != nil {
		panic(err)
	}
}

func Content(filename string) (*[]byte, error) {
	if file, ok := container[filename]; ok {
		return file.content, nil
	}
	return nil, fmt.Errorf("file2go %s not found", filename)
}

func ContentMust(filename string) *[]byte {
	content, err := Content(filename)
	if err != nil {
		panic(err)
	}
	return content
}

func ModTime(filename string) (*time.Time, error) {
	if file, ok := container[filename]; ok {
		return file.modTime, nil
	}
	return nil, fmt.Errorf("file2go %s not found", filename)
}

func ModTimeMust(filename string) *time.Time {
	modTime, err := ModTime(filename)
	if err != nil {
		panic(err)
	}
	return modTime
}

// eof
````

Content is GZIPed and BASE64 encoded.

This is likely to change without further notice so => DO NOT USE ;)

### Better Alternatives

[https://github.com/a-urth/go-bindata](https://github.com/a-urth/go-bindata) might provide a more production ready approach?